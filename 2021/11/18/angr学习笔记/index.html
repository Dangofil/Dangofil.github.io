<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>angr学习笔记 | violet-233の博客</title><meta name="keywords" content="re"><meta name="author" content="violet-233"><meta name="copyright" content="violet-233"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考链接：CTF-RE 题的神器 angr  ​                    angr 系列教程(一）核心概念及模块解读 - 先知社区 (aliyun.com) 符号执行介绍随着时代的发展，程序的流程越来越复杂，如果我们继续像以前那样在 ida 里仔细分析，肯定是太累了，所以有些科学家想要用自动化的算法来进行逆向工程，然后，他们就想到了符号执行这个算法。 符号执行算法听起来很高端，其实内">
<meta property="og:type" content="article">
<meta property="og:title" content="angr学习笔记">
<meta property="og:url" content="http://example.com/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="violet-233の博客">
<meta property="og:description" content="参考链接：CTF-RE 题的神器 angr  ​                    angr 系列教程(一）核心概念及模块解读 - 先知社区 (aliyun.com) 符号执行介绍随着时代的发展，程序的流程越来越复杂，如果我们继续像以前那样在 ida 里仔细分析，肯定是太累了，所以有些科学家想要用自动化的算法来进行逆向工程，然后，他们就想到了符号执行这个算法。 符号执行算法听起来很高端，其实内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eternitywith.gitee.io/image/32.jpg">
<meta property="article:published_time" content="2021-11-18T07:56:22.000Z">
<meta property="article:modified_time" content="2021-11-20T12:37:33.572Z">
<meta property="article:author" content="violet-233">
<meta property="article:tag" content="re">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eternitywith.gitee.io/image/32.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://example.com/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'angr学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-20 20:37:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../images/loading.png" data-original="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://eternitywith.gitee.io/image/32.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">violet-233の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">angr学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-18T07:56:22.000Z" title="发表于 2021-11-18 15:56:22">2021-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-20T12:37:33.572Z" title="更新于 2021-11-20 20:37:33">2021-11-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="angr学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>参考链接：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1370918-1-1.html">CTF-RE 题的神器 angr </a></p>
<p>​                    <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7117#toc-6">angr 系列教程(一）核心概念及模块解读 - 先知社区 (aliyun.com)</a></p>
<h2 id="符号执行介绍"><a href="#符号执行介绍" class="headerlink" title="符号执行介绍"></a>符号执行介绍</h2><p>随着时代的发展，程序的流程越来越复杂，如果我们继续像以前那样在 ida 里仔细分析，肯定是太累了，所以有些科学家想要用自动化的算法来进行逆向工程，然后，他们就想到了符号执行这个算法。</p>
<p>符号执行算法听起来很高端，其实内部算法却并不难理解。接下来就介绍一下这个符号执行的内部算法：</p>
<p>假如有这样一个程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_input = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> user_input - <span class="number">10</span> &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Success.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Try again.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们现在想要知道为了让程序到达 <code>print(&#39;Success.&#39;)</code>这一行，需要的输入条件是什么，那我们要怎么得出到达这一行的条件呢？首先我们来看看执行这个程序的时候，user_input 都经历了什么。</p>
<p><img src="../images/loading.png" data-original="/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/234717thykskmyacc5ahcy.jpg" alt="234717thykskmyacc5ahcy"></p>
<p>user_input 经过了一个判断语句，其中 <code>user_input - 10&gt;= 0</code> 就是成功的条件。所以很显然，我们只要将这个不等式接出来，就能知道需要的条件了。</p>
<p>那么假如说接下来有这样一个程序呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_input = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> user_input - <span class="number">10</span> &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> user_input &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Success.&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Try again.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Try again.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个程序稍微复杂了那么一点。但是这不是问题，我们照着解决上一个程序的方法，先看看 <code>user_input</code> 都经历了什么：</p>
<p><img src="../images/loading.png" data-original="/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/234746s4g9xccxcl5e2ffb.jpg" alt="234746s4g9xccxcl5e2ffb"></p>
<p>不难看出，<code>user_input</code>经历了个两个判断条件，所以这回我们为了得出输出成功的条件，我们得解一个方程组：</p>
<p><img src="../images/loading.png" data-original="/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/234748y01xy80xi9zyfqf1.jpg" alt="234748y01xy80xi9zyfqf1"></p>
<p>然后我们只要愉快的解出这个不等式组，就可以得到可能的输出了。</p>
<p>不难发现，就算你if语句再多，只要我能够一个个收集齐全，然后将这些条件形成一个不等式组，然后解出这个不等式组，就可以得到我们想要的输出了。</p>
<p>但是现实生活中的程序不可能这么简单，单凭人力是无法收集全的，那么我们自然是要用程序来收集。这个时候就该我们的angr登场了。</p>
<p>接下来我们通过一个程序来看看angr的使用方法和大概的工作流程</p>
<h2 id="angr上手教程"><a href="#angr上手教程" class="headerlink" title="angr上手教程"></a>angr上手教程</h2><h3 id="顶层接口"><a href="#顶层接口" class="headerlink" title="顶层接口"></a>顶层接口</h3><p>使用 angr 第一件事就是加载二进制文件，在 angr 中，基本上所有的对象操作都依赖于已有的 Project </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">proj = angr.Project(<span class="string">&#x27;C:\\Users\\86186\\Desktop\\re-题集\\00_angr_find&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p>载入二进制文件后，我们就可以访问一些基本属性，如架构、入口地址、文件名：</p>
<p>（具体环境配置看<code>Ubuntu安装python虚拟环境以及angr备忘</code>这篇博客）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proj.arch</span><br><span class="line">proj.entry</span><br><span class="line">proj.filename</span><br></pre></td></tr></table></figure>

<p><img src="../images/loading.png" data-original="/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211120171613783.png" alt="image-20211120171613783"></p>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>angr 中的 CLE 模块用于将二进制文件载入虚拟地址空间，而CLE 最主要的接口就是 loader 类。</p>
<p>可以通过 Project 的 <code>.loader</code>的属性查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj.loader</span><br></pre></td></tr></table></figure>

<p><img src="../images/loading.png" data-original="/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211120171738717.png" alt="image-20211120171738717"></p>
<p>通过 loader, 我们可以获得二进制文件的共享库、地址空间等信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj.loader.shared_objects</span><br></pre></td></tr></table></figure>

<p><img src="../images/loading.png" data-original="/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211120171906070.png" alt="image-20211120171906070"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proj.loader.min_addr</span><br><span class="line">proj.loader.max_addr</span><br></pre></td></tr></table></figure>

<h3 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h3><p>即 <code>AngrObjectFactory</code>，提供重要分析对象的接口，如 <code>blocks / state / SimulationManager</code> 等。</p>
<h4 id="blocks"><a href="#blocks" class="headerlink" title="blocks"></a>blocks</h4><p>即程序基本块，我们可以给定地址，获取对应的基本块，为 Block 对象。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">block</span> = proj.factory.<span class="keyword">block</span>(proj.<span class="built_in">entry</span>)</span><br><span class="line">&lt;<span class="keyword">Block</span> for <span class="number">0</span>x4017b0, <span class="number">42</span> bytes&gt;</span><br></pre></td></tr></table></figure>

<p>可以查看 Block 对象的信息或执行操作，以下是接口</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">block</span>.</span><br><span class="line"><span class="keyword">block</span>.BLOCK_MAX_SIZE          <span class="keyword">block</span>.instruction_addrs       <span class="keyword">block</span>.serialize_to_cmessage(</span><br><span class="line"><span class="keyword">block</span>.addr                    <span class="keyword">block</span>.instructions            <span class="keyword">block</span>.<span class="built_in">size</span></span><br><span class="line"><span class="keyword">block</span>.arch                    <span class="keyword">block</span>.parse(                  <span class="keyword">block</span>.thumb</span><br><span class="line"><span class="keyword">block</span>.bytes                   <span class="keyword">block</span>.parse_from_cmessage(    <span class="keyword">block</span>.vex</span><br><span class="line"><span class="keyword">block</span>.capstone                <span class="keyword">block</span>.pp(                     <span class="keyword">block</span>.vex_nostmt</span><br><span class="line"><span class="keyword">block</span>.codenode                <span class="keyword">block</span>.serialize(</span><br></pre></td></tr></table></figure>

<p><img src="../images/loading.png" data-original="/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211120172316669.png" alt="image-20211120172316669"></p>
<h4 id="states"><a href="#states" class="headerlink" title="states"></a>states</h4><p>Project 对象仅表示程序的初始镜像，而在执行时，我们实际上是对 SimState 对象进行操作，它代表程序的一个实例镜像，模拟执行某个时刻的状态。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">state</span> = proj.factory.entry_state()</span><br><span class="line"><span class="variable">&lt;SimState @ 0x401670&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>SimState</code> 对象包含程序运行时信息，如内存/寄存器/文件系统数据等。</p>
<p>我们可以通过 <code>state.regs</code> 和 <code>state.mem</code> 访问寄存器和内存信息。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.regs.rip</span><br><span class="line"><span class="variable">&lt;BV64 0x4017b0&gt;</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.regs.rax</span><br><span class="line"><span class="variable">&lt;BV64 0x1c&gt;</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.mem[proj.entry].int.resolved</span><br><span class="line"><span class="variable">&lt;BV32 0x8949ed31&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，返回的结果都是 BV 类型，并不是python 中的 int 类型，BV是位向量(bitvector)的简称，实际上就是一串比特序列，angr 使用位向量表示 CPU 数据。</p>
<p>以下展示位向量和 int 的相互转换</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bv = <span class="keyword">state</span>.solver.BVV(<span class="number">0</span>x1234, <span class="number">32</span>)       <span class="comment"># create a 32-bit-wide bitvector with value 0x1234</span></span><br><span class="line"><span class="variable">&lt;BV32 0x1234&gt;</span>                               <span class="comment"># BVV stands for bitvector value</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.solver.eval(bv)                <span class="comment"># convert to python int</span></span><br><span class="line"><span class="number">0</span>x1234</span><br></pre></td></tr></table></figure>

<p>我们可以存储位向量到寄存器/内存中，或者直接使用 int 类型，它会被自动转成位向量。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.regs.rsi = <span class="keyword">state</span>.solver.BVV(<span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.regs.rsi</span><br><span class="line"><span class="variable">&lt;BV64 0x3&gt;</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.mem[<span class="number">0</span>x1000].long = <span class="number">4</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.mem[<span class="number">0</span>x1000].long.resolved</span><br><span class="line"><span class="variable">&lt;BV64 0x4&gt;</span></span><br></pre></td></tr></table></figure>

<p>后续我们还会详细介绍位向量的操作。</p>
<p>对于 <code>state.mem</code> 接口：</p>
<ul>
<li><code>mem[ index ]</code> 指定地址</li>
<li><code>.&lt;type&gt;</code> 指定类型（如 <code>char, short, int, long, size_t, uint8_t, uint16_t...</code> ）</li>
<li><code>.resolved</code> 将数据输出为位向量。</li>
<li><code>.concrete</code> 将数据输出为int值。</li>
</ul>
<h4 id="Simulation-Managers"><a href="#Simulation-Managers" class="headerlink" title="Simulation Managers"></a>Simulation Managers</h4><blockquote>
<p>A simulation manager is the primary interface in angr for performing execution, simulation, whatever you want to call it, with states.</p>
</blockquote>
<p>SM(Simulation Managers) 用于管理 state，执行 运行、模拟等操作。</p>
<p>我们使用单个 state 或 state 列表创建 <code>Simulation Managers</code></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; simgr = proj.factory.simulation_manager(state)</span><br><span class="line">&gt;&gt;&gt; simgr.active</span><br><span class="line"><span class="meta">[&lt;SimState @ 0x4017b0&gt;]</span></span><br></pre></td></tr></table></figure>

<p>单个 SM 可以包含多个 stash(stash 中存放 state) ， 默认的stash 是 <code>active stash</code>，它使用我们传入的 <code>state</code>进行初始化。</p>
<p>接下来，我们进行简单的执行操作, 调用 step() 方法，这会执行一个基本块。</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">simgr.step()</span></span><br></pre></td></tr></table></figure>

<p>再次查看 <code>active</code>，可以看到已经从 <code>0x4017b0</code> 变为 <code>0x1021ab0</code> . 而初始 state 不会受到影响， 因为执行不会改变 <code>SimState</code> 对象。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; simgr.active</span><br><span class="line"><span class="meta">[&lt;SimState @ 0x1021ab0&gt;]</span></span><br><span class="line">&gt;&gt;&gt; simgr.active[<span class="number">0</span>].regs.rip</span><br><span class="line">&lt;BV64 <span class="number">0x1021ab0</span>&gt;</span><br><span class="line">&gt;&gt;&gt; state.regs.rip          </span><br><span class="line">&lt;BV64 <span class="number">0x4017b0</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a>Analyses</h3><p>angr 内置了一些分析方法，用于提取程序信息。接口位于 <code>proj.analyses.</code> 中</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; proj<span class="selector-class">.analyses</span>.</span><br><span class="line">proj<span class="selector-class">.analyses</span><span class="selector-class">.BackwardSlice</span>(              proj<span class="selector-class">.analyses</span><span class="selector-class">.Decompiler</span>(                 proj<span class="selector-class">.analyses</span><span class="selector-class">.VFG</span>(</span><br><span class="line">proj<span class="selector-class">.analyses</span><span class="selector-class">.BasePointerSaveSimplifier</span>(  proj<span class="selector-class">.analyses</span><span class="selector-class">.DefUseAnalysis</span>(             proj<span class="selector-class">.analyses</span><span class="selector-class">.VSA_DDG</span>(</span><br><span class="line">proj<span class="selector-class">.analyses</span><span class="selector-class">.BinDiff</span>(                    proj<span class="selector-class">.analyses</span><span class="selector-class">.Disassembly</span>(               proj<span class="selector-class">.analyses</span><span class="selector-class">.VariableRecovery</span>(</span><br><span class="line">proj<span class="selector-class">.analyses</span><span class="selector-class">.BinaryOptimizer</span>(            proj<span class="selector-class">.analyses</span><span class="selector-class">.DominanceFrontier</span>(         proj<span class="selector-class">.analyses</span><span class="selector-class">.VariableRecoveryFast</span>(       .....</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是顶层接口的说明，通过以上介绍，我们对 angr 有了初步的认识。</p>
<p>通常使用 angr 的步骤大概如下:</p>
<ol>
<li>创建 project 并设置state</li>
<li>新建符号量/位向量 并在内存或其他地方设置</li>
<li>设置 Simulation Managers</li>
<li>运行，探索满足需要的路径</li>
<li>约束求解，获取执行结果</li>
</ol>
<p>接下来，我们对几个核心模块进行介绍。</p>
<h2 id="loader-加载模块"><a href="#loader-加载模块" class="headerlink" title="loader 加载模块"></a>loader 加载模块</h2><p>将二进制文件加载到虚拟的地址空间</p>
<p>通过我们可以 loader 对查看加载对象、符号重定位信息等，同时也可以设置初始的加载选项。</p>
<ul>
<li>已加载的对象</li>
<li>符号和重定位</li>
<li>加载选项</li>
</ul>
<h3 id="已加载的对象"><a href="#已加载的对象" class="headerlink" title="已加载的对象"></a>已加载的对象</h3><p>获取对象，可以通过以下接口获取对应的对象。</p>
<ul>
<li><code>.all_objects/shared_objects/all_elf_objects/extern_object/kernel_object</code></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; obj = proj<span class="selector-class">.loader</span><span class="selector-class">.main_object</span></span><br><span class="line">&lt;ELF Object true, maps <span class="selector-attr">[0x400000:0x60721f]</span>&gt;</span><br><span class="line">&gt;&gt;&gt; obj = proj<span class="selector-class">.loader</span><span class="selector-class">.all_objects</span></span><br><span class="line"><span class="selector-attr">[&lt;ELF Object true, maps [0x400000:0x60721f]</span>&gt;, &lt;ExternObject Object cle#<span class="selector-id">#externs</span>, maps <span class="selector-attr">[0x1000000:0x1008000]</span>&gt;, &lt;ELFTLSObject Object cle#<span class="selector-id">#tls</span>, maps <span class="selector-attr">[0x2000000:0x2015010]</span>&gt;, &lt;KernelObject Object cle#<span class="selector-id">#kernel</span>, maps <span class="selector-attr">[0x3000000:0x3008000]</span>&gt;]</span><br></pre></td></tr></table></figure>

<p>获得加载对象后，直接与这些对象进行交互从中提取元数据，如：</p>
<ul>
<li>获取 ELF 的内存分段和文件分段</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; obj.sections                     </span><br><span class="line">&lt;Regions: [&lt;Unnamed | <span class="built_in">offset</span> <span class="number">0x0</span>, vaddr <span class="number">0x400000</span>, size <span class="number">0x0</span>&gt;, &lt;.interp | <span class="built_in">offset</span> <span class="number">0x238</span>, vaddr <span class="number">0x400238</span>, size <span class="number">0x1c</span>&gt;, &lt;.note.ABI-tag | <span class="built_in">offset</span> <span class="number">0x254</span>, vaddr <span class="number">0x400254</span>, size <span class="number">0x20</span>&gt;, &lt;.note.gnu.build-<span class="built_in">id</span> | <span class="built_in">offset</span> <span class="number">0x274</span>, vaddr <span class="number">0x400274</span>, size <span class="number">0x24</span>&gt;, &lt;.gnu.hash | <span class="built_in">offset</span> <span class="number">0x298</span>, vaddr <span class="number">0x400298</span>, size <span class="number">0x64</span>&gt;,...</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 PLT 表信息</li>
</ul>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; obj.<span class="keyword">plt</span></span><br><span class="line">&#123;<span class="string">&#x27;__uflow&#x27;</span>: <span class="number">0x401400</span>,</span><br><span class="line"> <span class="string">&#x27;getenv&#x27;</span>: <span class="number">0x401410</span>,</span><br><span class="line"> <span class="string">&#x27;free&#x27;</span>: <span class="number">0x401420</span>,</span><br><span class="line"> <span class="string">&#x27;abort&#x27;</span>: <span class="number">0x401430</span>,</span><br><span class="line"> <span class="string">&#x27;__errno_location&#x27;</span>: <span class="number">0x401440</span>,</span><br><span class="line"> <span class="string">&#x27;strncmp&#x27;</span>: <span class="number">0x401450</span>,</span><br><span class="line"> <span class="string">&#x27;_exit&#x27;</span>: <span class="number">0x401460</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>显示预链接基址和实际装载的内存基址等地址信息</li>
</ul>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">obj.linked_base</span></span><br><span class="line">0x0</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">obj.mapped_base</span></span><br><span class="line">0x400000</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">obj.max_addr</span></span><br><span class="line">0x60721f</span><br></pre></td></tr></table></figure>

<ul>
<li>….</li>
</ul>
<h3 id="符号和重定位"><a href="#符号和重定位" class="headerlink" title="符号和重定位"></a>符号和重定位</h3><p>使用 CLE 操作二进制的符号信息</p>
<h4 id="查找符号"><a href="#查找符号" class="headerlink" title="查找符号"></a>查找符号</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; malloc = proj<span class="selector-class">.loader</span><span class="selector-class">.find_symbol</span>(<span class="string">&#x27;malloc&#x27;</span>)</span><br><span class="line">&lt;Symbol <span class="string">&quot;malloc&quot;</span> <span class="keyword">in</span> extern-<span class="selector-tag">address</span> space at <span class="number">0</span>x10002c0&gt;</span><br></pre></td></tr></table></figure>

<p>如果要获得对象的 symbol，则使用 <code>get_symbol</code> 方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc = proj<span class="selector-class">.loader</span><span class="selector-class">.main_object</span><span class="selector-class">.get_symbol</span>(<span class="string">&#x27;malloc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们会得到一个 symbol 对象，可以获取获取符号名/所属者/链接地址/相对地址等信息。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; malloc.</span><br><span class="line">malloc.is_common           malloc.is_local            malloc.owner_obj           malloc.resolvedby</span><br><span class="line">malloc.is_export           malloc.is_static           malloc.rebased_addr        malloc.size</span><br><span class="line">malloc.is_extern           malloc.is_weak             malloc.relative_addr       malloc.subtype</span><br><span class="line">malloc.is_forward          malloc.linked_addr         malloc.<span class="built_in">resolve</span>(            malloc.type</span><br><span class="line">malloc.is_function         malloc.name                malloc.<span class="built_in">resolve_forwarder</span>(  </span><br><span class="line">malloc.is_import           malloc.owner               malloc.resolved</span><br></pre></td></tr></table></figure>

<p>symbol 对象有三种获取其地址的方式：</p>
<ul>
<li><code>.rebased_addr</code>: 在全局地址空间的地址。</li>
<li><code>.linked_addr</code>: 相对于二进制的预链接基址的地址。</li>
<li><code>.relative_addr</code>: 相对于对象基址的地址。</li>
</ul>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">malloc.rebased_addr</span></span><br><span class="line">0x10002c0</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">malloc.linked_addr </span></span><br><span class="line">0x2c0     </span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">malloc.relative_addr</span></span><br><span class="line">0x2c0</span><br></pre></td></tr></table></figure>

<h3 id="加载选项"><a href="#加载选项" class="headerlink" title="加载选项"></a>加载选项</h3><h4 id="基本选项"><a href="#基本选项" class="headerlink" title="基本选项"></a>基本选项</h4><table>
<thead>
<tr>
<th>名称</th>
<th><code>描述</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>auto_load_libs</code></td>
<td>是否自动加载程序的依赖</td>
</tr>
<tr>
<td><code>skip_libs</code></td>
<td>避免加载的库</td>
</tr>
<tr>
<td><code>except_missing_libs</code></td>
<td>无法解析共享库时是否抛出异常</td>
</tr>
<tr>
<td><code>force_load_libs</code></td>
<td>强制加载的库</td>
</tr>
<tr>
<td><code>ld_path</code></td>
<td>共享库的优先搜索搜寻路径</td>
</tr>
</tbody></table>
<p>在进行一些程序分析时，如果 auto_load_libs 为 True, angr 会同时分析动态链接库，导致耗时非常久，所以可以根据自己需要设置恰当的值。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; proj = angr<span class="selector-class">.Project</span>(<span class="string">&#x27;/bin/true&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; proj<span class="selector-class">.loader</span><span class="selector-class">.shared_objects</span></span><br><span class="line"><span class="function"><span class="title">OrderedDict</span><span class="params">([(<span class="string">&#x27;true&#x27;</span>, &lt;ELF Object true, maps [<span class="number">0</span>x400000:<span class="number">0</span>x60721f]&gt;)</span></span>, (<span class="string">&#x27;libc.so.6&#x27;</span>, &lt;ELF Object libc-<span class="number">2.27</span><span class="selector-class">.so</span>, maps <span class="selector-attr">[0x1000000:0x13f0adf]</span>&gt;), (<span class="string">&#x27;ld-linux-x86-64.so.2&#x27;</span>, &lt;ELF Object ld-<span class="number">2.27</span><span class="selector-class">.so</span>, maps <span class="selector-attr">[0x2000000:0x222916f]</span>&gt;)])</span><br><span class="line">&gt;&gt;&gt; proj = angr<span class="selector-class">.Project</span>(<span class="string">&#x27;/bin/true&#x27;</span>, load_options=&#123;<span class="string">&quot;auto_load_libs&quot;</span>: False&#125;)</span><br><span class="line">&gt;&gt;&gt; proj<span class="selector-class">.loader</span><span class="selector-class">.shared_objects</span></span><br><span class="line"><span class="function"><span class="title">OrderedDict</span><span class="params">([(<span class="string">&#x27;true&#x27;</span>, &lt;ELF Object true, maps [<span class="number">0</span>x400000:<span class="number">0</span>x60721f]&gt;)</span></span>])</span><br></pre></td></tr></table></figure>

<h4 id="pre-binary-选项"><a href="#pre-binary-选项" class="headerlink" title="pre-binary 选项"></a>pre-binary 选项</h4><p>在加载二进制文件时可以设置特定的参数，使用 <code>main_opts</code> 和 <code>lib_opts</code> 参数进行设置。</p>
<ul>
<li><code>backend</code> - 指定 backend</li>
<li><code>base_addr</code> - 指定基址</li>
<li><code>entry_point</code> - 指定入口点</li>
<li><code>arch</code> - 指定架构</li>
</ul>
<p>示例如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; angr.<span class="constructor">Project(&#x27;<span class="params">examples</span><span class="operator">/</span><span class="params">fauxware</span><span class="operator">/</span><span class="params">fauxware</span>&#x27;, <span class="params">main_opts</span>=&#123;&#x27;<span class="params">backend</span>&#x27;: &#x27;<span class="params">blob</span>&#x27;, &#x27;<span class="params">arch</span>&#x27;: &#x27;<span class="params">i386</span>&#x27;&#125;, <span class="params">lib_opts</span>=&#123;&#x27;<span class="params">libc</span>.<span class="params">so</span>.6&#x27;: &#123;&#x27;<span class="params">backend</span>&#x27;: &#x27;<span class="params">elf</span>&#x27;&#125;&#125;)</span></span><br><span class="line">&lt;Project examples/fauxware/fauxware&gt;</span><br></pre></td></tr></table></figure>

<h3 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h3><p>一般情况下，CLE 会自动选择对应的 backend，也可以自己指定。有的 backend 需要 同时指定架构。</p>
<p>以下是各个 backend 以及描述：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>elf</td>
<td>ELF文件的静态加载器 (基于PyELFTools)</td>
</tr>
<tr>
<td>pe</td>
<td>PE文件静态加载器 (基于PEFile)</td>
</tr>
<tr>
<td>mach-o</td>
<td>Mach-O文件的静态加载器</td>
</tr>
<tr>
<td>cgc</td>
<td>CGC (Cyber Grand Challenge)二进制的静态加载器</td>
</tr>
<tr>
<td>backedcgc</td>
<td>CGC 二进制的静态加载器，允许指定内存和寄存器</td>
</tr>
<tr>
<td>elfcore</td>
<td>ELF 核心转储的静态加载器</td>
</tr>
<tr>
<td>blob</td>
<td>将文件作为平面镜像加载到内存中</td>
</tr>
</tbody></table>
<p>注：IDA backend 在 angr 8.18.10.25 中已被移除。</p>
<h2 id="符号函数摘要集-symbolic-funcion-summaries"><a href="#符号函数摘要集-symbolic-funcion-summaries" class="headerlink" title="符号函数摘要集(symbolic funcion summaries)"></a>符号函数摘要集(symbolic funcion summaries)</h2><p>默认情况下，angr 会使用 <code>SimProcedures</code> 中的符号摘要替换库函数，即设置 Hooking，这些 python 函数摘要高效地模拟库函数对状态的影响。可以通过 <code>angr.procedures</code>或 <code>angr.SimProcedures</code> 查看列表。</p>
<p><code>SimProcedures</code> 是一个两层的字典，第一层表示包名，第二层表示函数名。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; angr<span class="selector-class">.procedures</span>.</span><br><span class="line">angr<span class="selector-class">.procedures</span><span class="selector-class">.SIM_PROCEDURES</span>  angr<span class="selector-class">.procedures</span><span class="selector-class">.java_lang</span>       angr<span class="selector-class">.procedures</span><span class="selector-class">.stubs</span></span><br><span class="line">angr<span class="selector-class">.procedures</span><span class="selector-class">.SimProcedures</span>   angr<span class="selector-class">.procedures</span><span class="selector-class">.java_util</span>       angr<span class="selector-class">.procedures</span><span class="selector-class">.testing</span></span><br><span class="line">angr<span class="selector-class">.procedures</span><span class="selector-class">.advapi32</span>        angr<span class="selector-class">.procedures</span><span class="selector-class">.libc</span>            angr<span class="selector-class">.procedures</span><span class="selector-class">.tracer</span></span><br><span class="line">angr<span class="selector-class">.procedures</span><span class="selector-class">.cgc</span>             angr<span class="selector-class">.procedures</span><span class="selector-class">.linux_kernel</span>    angr<span class="selector-class">.procedures</span><span class="selector-class">.uclibc</span></span><br><span class="line">angr<span class="selector-class">.procedures</span><span class="selector-class">.definitions</span>     angr<span class="selector-class">.procedures</span><span class="selector-class">.linux_loader</span>    angr<span class="selector-class">.procedures</span><span class="selector-class">.win32</span></span><br><span class="line">angr<span class="selector-class">.procedures</span><span class="selector-class">.glibc</span>           angr<span class="selector-class">.procedures</span><span class="selector-class">.msvcr</span>           .......</span><br><span class="line">&gt;&gt;&gt; angr<span class="selector-class">.procedures</span><span class="selector-class">.libc</span><span class="selector-class">.malloc</span></span><br><span class="line">&lt;module <span class="string">&#x27;angr.procedures.libc.malloc&#x27;</span> from <span class="string">&#x27;/home/angr/angr-dev/angr/angr/procedures/libc/malloc.py&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt; angr<span class="selector-class">.SIM_PROCEDURES</span><span class="selector-attr">[<span class="string">&#x27;libc&#x27;</span>]</span><span class="selector-attr">[<span class="string">&#x27;malloc&#x27;</span>]</span></span><br><span class="line">&lt;class <span class="string">&#x27;angr.procedures.libc.malloc.malloc&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以设置参数 <code>exclude_sim_procedures_list</code> 和 <code>exclude_sim_procedures_func</code> 指定不想被 <code>SimProcedure</code> 替代的符号。</p>
<p>此外，关于 SimProcedure 的不准确性<a target="_blank" rel="noopener" href="https://docs.angr.io/advanced-topics/gotchas">文档</a> 有提到。</p>
<h4 id="Hooking"><a href="#Hooking" class="headerlink" title="Hooking"></a>Hooking</h4><p><code>SimProcedure</code> 其实就是 Hook 机制，可以通过 <code>proj.hook(addr,hook)</code> 设置，其中 hook 是一个 <code>SimProcedure</code> 实例。 通过 <code>.is_hooked / .unhook / .hook_by</code> 进行管理。</p>
<p>将 <code>proj.hook(addr)</code> 作为函数装饰器，可以编写自己的 hook 函数。。</p>
<p>还可以通过 <code>proj.hook_symbol(name,hook)</code> hook 函数。</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">stub_func = angr.SIM_PROCEDURES[<span class="string">&#x27;stubs&#x27;</span>][<span class="string">&#x27;ReturnUnconstrained&#x27;</span>] <span class="comment"># this is a CLASS</span></span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">proj.hook(<span class="number">0x10000</span>, stub_func())  <span class="comment"># hook with an instance of the class</span></span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">proj.is_hooked(<span class="number">0x10000</span>)            <span class="comment"># these functions should be pretty self-explanitory</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">proj.hooked_by(<span class="number">0x10000</span>)</span></span><br><span class="line">&lt;ReturnUnconstrained&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">proj.unhook(<span class="number">0x10000</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="meta">@proj.hook(<span class="params"><span class="number">0x20000</span>, length=<span class="number">5</span></span>)</span></span></span><br><span class="line"><span class="meta">...</span> <span class="python"><span class="function"><span class="keyword">def</span> <span class="title">my_hook</span>(<span class="params">state</span>):</span></span></span><br><span class="line"><span class="meta">...</span> <span class="python">    state.regs.rax = <span class="number">1</span></span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">proj.is_hooked(<span class="number">0x20000</span>)</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="states-1"><a href="#states-1" class="headerlink" title="states"></a>states</h2><p>state 代表程序的一个实例镜像，模拟执行某个时刻的状态。保存运行状态的上下文信息，如内存/寄存器等。</p>
<p>在执行开始之前，我们通过设置 state 对象初始化寄存器/内存/栈帧等信息。在结束执行后，会返回 state 对象，可以提取需要的值进行求解。</p>
<h4 id="基础执行"><a href="#基础执行" class="headerlink" title="基础执行"></a>基础执行</h4><p>使用 <code>state.step()</code>接口进行简单的执行，该方法会返回一个 <code>SimSuccessors</code> 对象，该对象有个 <code>.successors</code> 属性 , 是后继状态的列表。</p>
<p>关于执行，在 SM 中同样涉及，通常使用 SM 管理 state 的执行。</p>
<h4 id="状态预设"><a href="#状态预设" class="headerlink" title="状态预设"></a>状态预设</h4><p>除了使用<code>.entry_state()</code> 创建 state 对象, 我们还可以根据需要使用其他构造函数创建 state:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>.entry_state()</code></td>
<td>constructs a state ready to execute at the main binary’s entry point.</td>
</tr>
<tr>
<td><code>.blank_state</code></td>
<td>constructs a “blank slate” blank state, with most of its data left uninitialized.</td>
</tr>
<tr>
<td><code>.call_state</code></td>
<td>When accessing uninitialized data, an unconstrained symbolic value will be returned.constructs a state ready to execute a given function.</td>
</tr>
<tr>
<td><code>.full_init_state</code></td>
<td>constructs a state that is ready to execute through any initializers that need to be run before the main binary’s entry point</td>
</tr>
</tbody></table>
<h4 id="访问寄存器"><a href="#访问寄存器" class="headerlink" title="访问寄存器"></a>访问寄存器</h4><p>通过 <code>state.regs</code> 对象的属性访问以及修改寄存器的数据</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.regs.r  </span><br><span class="line"><span class="keyword">state</span>.regs.r10                <span class="keyword">state</span>.regs.r13w               <span class="keyword">state</span>.regs.r9d</span><br><span class="line"><span class="keyword">state</span>.regs.r10b               <span class="keyword">state</span>.regs.r14                <span class="keyword">state</span>.regs.r9w</span><br><span class="line"><span class="keyword">state</span>.regs.r10d               <span class="keyword">state</span>.regs.r14b               <span class="keyword">state</span>.regs.rax</span><br><span class="line"><span class="keyword">state</span>.regs.r10w               <span class="keyword">state</span>.regs.r14d               <span class="keyword">state</span>.regs.rbp</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.regs.rip</span><br><span class="line"><span class="variable">&lt;BV64 0x4017b0&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="访问内存"><a href="#访问内存" class="headerlink" title="访问内存"></a>访问内存</h4><p>前面提到可以通过 <code>state.mem[index]</code> 访问内存，但对于一段连续内存的操作十分不方便。</p>
<p>因此我们也可以使用 <code>state.memory</code> 的 <code>.load(addr, size) / .store(addr, val)</code> 接口读写内存, size 以 bytes 为单位。</p>
<p>以下 load 和 store 的函数声明和一些参数解释：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def load(self, addr, <span class="attribute">size</span>=None, <span class="attribute">condition</span>=None, <span class="attribute">fallback</span>=None, <span class="attribute">add_constraints</span>=None, <span class="attribute">action</span>=None, <span class="attribute">endness</span>=None,</span><br><span class="line">             <span class="attribute">inspect</span>=<span class="literal">True</span>, <span class="attribute">disable_actions</span>=<span class="literal">False</span>, <span class="attribute">ret_on_segv</span>=<span class="literal">False</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        Loads size bytes from dst.</span></span><br><span class="line"><span class="string">        :param addr:             The address to load from. #读取的地址</span></span><br><span class="line"><span class="string">        :param size:            The size (in bytes) of the load. #大小</span></span><br><span class="line"><span class="string">        :param condition:       A claripy expression representing a condition for a conditional load.</span></span><br><span class="line"><span class="string">        :param fallback:        A fallback value if the condition ends up being False. </span></span><br><span class="line"><span class="string">        :param add_constraints: Add constraints resulting from the merge (default: True).</span></span><br><span class="line"><span class="string">        :param action:          A SimActionData to fill out with the constraints.</span></span><br><span class="line"><span class="string">        :param endness:         The endness to load with. #端序</span></span><br><span class="line"><span class="string">       ....</span></span><br><span class="line"><span class="string">def store(self, addr, data, size=None, condition=None, add_constraints=None, endness=None, action=None,</span></span><br><span class="line"><span class="string">              inspect=True, priv=None, disable_actions=False):</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        Stores content into memory.</span><br><span class="line">        :param addr:        A claripy expression representing the<span class="built_in"> address </span><span class="keyword">to</span> store at. #内存地址</span><br><span class="line">        :param data:        The data <span class="keyword">to</span> store (claripy expression <span class="keyword">or</span> something convertable <span class="keyword">to</span> a claripy expression).#写入的数据</span><br><span class="line">        :param size:        A claripy expression representing the size of the data <span class="keyword">to</span> store. #大小</span><br><span class="line">        <span class="built_in">..</span>.</span><br><span class="line">&gt;&gt;&gt; s = proj.factory.blank_state()</span><br><span class="line">&gt;&gt;&gt; s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128))</span><br><span class="line">&gt;&gt;&gt; s.memory.load(0x4004, 6) # load-size is <span class="keyword">in</span> bytes</span><br><span class="line">&lt;BV48 0x89abcdef0123&gt;</span><br></pre></td></tr></table></figure>

<p>参数 <code>endness</code> 用于设置端序。</p>
<p>可选的值如下</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LE – 小端序(little endian, least significant <span class="keyword">byte </span>is stored <span class="built_in">at</span> lowest <span class="keyword">address)</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">BE </span>– 大端序(<span class="keyword">big </span>endian, most significant <span class="keyword">byte </span>is stored <span class="built_in">at</span> lowest <span class="keyword">address)</span></span><br><span class="line"><span class="keyword"></span>ME – 中间序(Middle-endian. Yep.)</span><br><span class="line">&gt;&gt;&gt; import archinfo</span><br><span class="line">&gt;&gt;&gt; s.memory.load(<span class="number">0x4000</span>, <span class="number">4</span>, endness=archinfo.Endness.LE)</span><br><span class="line">&lt;<span class="keyword">BV32 </span><span class="number">0x67453201</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="状态选项"><a href="#状态选项" class="headerlink" title="状态选项"></a>状态选项</h4><p><code>SimState</code> 包含 <code>.options</code> 属性，它是所有开启的状态选项的集合。</p>
<p>状态通过 <code>angr.options.&lt;name&gt;</code>获得，具体的选项可以查看 <a target="_blank" rel="noopener" href="https://docs.angr.io/appendix/options">列表</a> 。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; angr.<span class="keyword">options</span>.</span><br><span class="line"><span class="keyword">Display</span> <span class="keyword">all</span> <span class="number">143</span> possibilities? (y <span class="keyword">or</span> n)</span><br><span class="line">angr.<span class="keyword">options</span>.ABSTRACT_MEMORY</span><br><span class="line">angr.<span class="keyword">options</span>.ABSTRACT_SOLVER</span><br><span class="line">angr.<span class="keyword">options</span>.ACTION_DEPS</span><br><span class="line">angr.<span class="keyword">options</span>.ALLOW_SEND_FAILURES</span><br><span class="line">angr.<span class="keyword">options</span>.ALL_FILES_EXIST</span><br><span class="line">angr.<span class="keyword">options</span>.APPROXIMATE_FIRST</span><br><span class="line">angr.<span class="keyword">options</span>.APPROXIMATE_GUARDS</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>可以直接对 <code>.options</code>集合进行操作，添加选项。</p>
<p>在创建 <code>SimState</code> 对象时，可以通过关键字参数 <code>add_options</code> 和 <code>remove_options</code> 设置选项。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.options.add(angr.options.LAZY_SOLVES)</span><br><span class="line"># Create a <span class="keyword">new</span> state <span class="keyword">with</span> <span class="keyword">lazy</span> solves enabled</span><br><span class="line">&gt;&gt;&gt; s = proj.factory.entry<span class="constructor">_state(<span class="params">add_options</span>=&#123;<span class="params">angr</span>.<span class="params">options</span>.LAZY_SOLVES&#125;)</span></span><br><span class="line"># Create a <span class="keyword">new</span> state without simplification options enabled</span><br><span class="line">&gt;&gt;&gt; s = proj.factory.entry<span class="constructor">_state(<span class="params">remove_options</span>=<span class="params">angr</span>.<span class="params">options</span>.<span class="params">simplification</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="状态插件（state-plugin"><a href="#状态插件（state-plugin" class="headerlink" title="状态插件（state plugin)"></a>状态插件（state plugin)</h4><p>除了前面提到的 options， <code>SimState</code> 中的内容都是以插件的方式进行存储，这种设计可以模块化，方便维护和拓展。</p>
<p>这些插件称为状态插件（state plugin)，angr 内部实现了多种插件。如 memory / history / globals / callstack 等。</p>
<p><code>memory</code> 插件前面已经提到(内存访问章节)，下面简单介绍 history 和 callstack 插件。</p>
<h5 id="history-插件"><a href="#history-插件" class="headerlink" title="history 插件"></a>history 插件</h5><p>该插件记录状态的执行路径，实际上是 <code>history</code> 结点的链表，可以通过 <code>.parent</code> 来遍历列表。</p>
<p>history 存储的一些值以 <code>history.recent_NAME</code> 格式命名，对应的迭代器为 <code>history.NAME</code> 。</p>
<p>如以下代码会按顺序输出基本块的地址。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> <span class="keyword">state</span>.history.bbl_addrs: </span><br><span class="line">    print hex(addr)</span><br></pre></td></tr></table></figure>

<p>如果想快速查看链表的所有结点，可以使用 <code>.hardcopy</code> 方法，例<code>state.history.bbl_addrs.hardcopy</code></p>
<p>以下是 <code>history</code> 存储的部分值：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>history.descriptions</code></td>
<td>a listing of string descriptions of each of the rounds of execution performed on the state.</td>
</tr>
<tr>
<td><code>history.bbl_addrs</code></td>
<td>a listing of the basic block addresses executed by the state.</td>
</tr>
<tr>
<td><code>history.jumpkinds</code></td>
<td>a listing of the disposition of each of the control flow transitions in the state’s history, as VEX enum strings.</td>
</tr>
<tr>
<td><code>history.events</code></td>
<td>a semantic listing of “interesting events” which happened during execution, such as the presence of a symbolic jump condition, the program popping up a message box, or execution terminating with an exit code.</td>
</tr>
<tr>
<td><code>history.actions</code></td>
<td>usually empty, but if you add the <code>angr.options.refs</code> options to the state, it will be populated with a log of all the memory, register, and temporary value accesses performed by the program.</td>
</tr>
</tbody></table>
<h5 id="调用栈（callstack）插件"><a href="#调用栈（callstack）插件" class="headerlink" title="调用栈（callstack）插件"></a>调用栈（callstack）插件</h5><p>该插件记录执行时栈帧的信息，也是链表格式。可以直接对 <code>state.callstack</code> 进行迭代获得每次执行的栈帧信息。直接访问 <code>state.callstack</code> 可以获得当前状态的调用栈。</p>
<p>以下是 <code>callstack</code> 记录的部分信息：</p>
<ul>
<li><code>callstack.func_addr</code> ： the address of the function currently being executed</li>
<li><code>callstack.call_site_addr</code>： the address of the basic block which called the current function</li>
<li><code>callstack.stack_ptr</code> : he value of the stack pointer from the beginning of the current function</li>
<li><code>callstack.ret_addr</code> : the location that the current function will return to if it returns</li>
</ul>
<p>此外，angr 还内置了许多其他的状态插件，比如 heap、gdb、libc、 filesystem等等，位于 <code>angr/state_plugin</code> 目录。</p>
<p>除了使用内置状态插件外，我们也可以编写自己的插件，具体查看<a target="_blank" rel="noopener" href="https://docs.angr.io/extending-angr/state_plugins">文档说明</a></p>
<h2 id="模拟管理器（Simulation-Managers"><a href="#模拟管理器（Simulation-Managers" class="headerlink" title="模拟管理器（Simulation Managers)"></a>模拟管理器（Simulation Managers)</h2><p>前面已经介绍过 SM，通过它我们可以同时控制一组 state 的符号执行。我们可以通过 stash 对一组 state 进行执行、筛选、合并和移动等操作。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; simgr = proj.factory.simulation_manager(<span class="keyword">state</span>)</span><br><span class="line"><span class="variable">&lt;SimulationManager with 1 active&gt;</span></span><br></pre></td></tr></table></figure>

<p>出于方便，我们也可以使用 <code>.simulation_manager</code>的简写 <code>.simgr</code>，如果不传入 <code>state</code>, angr 会使用 <code>entry_state</code> 进行初始化。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; simgr = proj.factory.simgr()</span><br><span class="line">&gt;&gt;&gt; simgr.active</span><br><span class="line"><span class="meta">[&lt;SimState @ 0x4017b0&gt;]</span></span><br></pre></td></tr></table></figure>

<p>SM 包含多个 stash（<code>active/deadended/pruned</code> 等），大部分操作默认的 stash 为 active 。可以设定参数指定 stash。</p>
<p>SM 三个重要的接口： <code>step</code>, <code>explore</code>, and <code>use_technique</code></p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>SM 提供两种基本的执行方法：</p>
<ul>
<li>step() : 让 stash 中的所有状态都执行一个基本块，默认的 stash 为 active</li>
<li>run() : 一直执行到结束</li>
</ul>
<h3 id="stash-管理"><a href="#stash-管理" class="headerlink" title="stash 管理"></a>stash 管理</h3><p>SM 中使用 stash 管理 state。一个 stash 包含多个 state。可以以 SM 属性的格式访问这些 stash, 如 .active。我们也可以根据需要创建新的 stash。</p>
<p>使用 .move 可以进行 stash 间的移动。每一个 stash 都是一个列表，可以通过索引或者迭代访问里面的数据。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; simgr.move(<span class="attribute">from_stash</span>=<span class="string">&#x27;deadended&#x27;</span>, <span class="attribute">to_stash</span>=<span class="string">&#x27;authenticated&#x27;</span>, <span class="attribute">filter_func</span>=lambda s: b<span class="string">&#x27;Welcome&#x27;</span> <span class="keyword">in</span> s.posix.dumps(1))</span><br><span class="line">&gt;&gt;&gt; simgr</span><br><span class="line">&lt;SimulationManager with 2 authenticated, 1 deadended&gt;</span><br></pre></td></tr></table></figure>

<p>angr 会对 state 进行分类，归到不同的 stash，以下是部分特殊 stash 列表</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>active</td>
<td>This stash contains the states that will be stepped by default, unless an alternate stash is specified.</td>
</tr>
<tr>
<td>deadend</td>
<td>A state goes to the deadended stash when it cannot continue the execution for some reason, including no more valid instructions, unsat state of all of its successors, or an invalid instruction pointer.</td>
</tr>
<tr>
<td>pruned</td>
<td>When using <code>LAZY_SOLVES</code>, states are not checked for satisfiability unless absolutely necessary. When a state is found to be unsat in the presence of <code>LAZY_SOLVES</code>, the state hierarchy is traversed to identify when, in its history, it initially became unsat. All states that are descendants of that point (which will also be unsat, since a state cannot become un-unsat) are pruned and put in this stash.</td>
</tr>
<tr>
<td>unconstrained</td>
<td>If the <code>save_unconstrained</code> option is provided to the SimulationManager constructor, states that are determined to be unconstrained (i.e., with the instruction pointer controlled by user data or some other source of symbolic data) are placed here.</td>
</tr>
<tr>
<td>unsat</td>
<td>If the <code>save_unsat</code> option is provided to the SimulationManager constructor, states that are determined to be unsatisfiable (i.e., they have constraints that are contradictory, like the input having to be both “AAAA” and “BBBB” at the same time) are placed here.</td>
</tr>
</tbody></table>
<h3 id="explore"><a href="#explore" class="headerlink" title="explore"></a>explore</h3><p>通过调用 explore 方法，我们可以探索执行路径，在进行 explore 时，可以设置 find 和 avoid 参数，以便找到符合我们预期的路径。</p>
<p>函数接口如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def explore(self, <span class="attribute">stash</span>=<span class="string">&#x27;active&#x27;</span>, <span class="attribute">n</span>=None, <span class="attribute">find</span>=None, <span class="attribute">avoid</span>=None, <span class="attribute">find_stash</span>=<span class="string">&#x27;found&#x27;</span>, <span class="attribute">avoid_stash</span>=<span class="string">&#x27;avoid&#x27;</span>, <span class="attribute">cfg</span>=None,</span><br><span class="line">                <span class="attribute">num_find</span>=1, **kwargs):</span><br><span class="line">&gt;&gt;&gt;  proj = angr.Project(<span class="string">&#x27;examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; simgr = proj.factory.simgr()</span><br><span class="line">&gt;&gt;&gt; simgr.explore(<span class="attribute">find</span>=lambda s: b<span class="string">&quot;Congrats&quot;</span> <span class="keyword">in</span> s.posix.dumps(1))</span><br><span class="line">&lt;SimulationManager with 1 active, 1 found&gt;</span><br><span class="line">&gt;&gt;&gt; s = simgr.found[0]  # 获取通过 explore 找到符合条件的状态</span><br><span class="line">&gt;&gt;&gt; flag = s.posix.dumps(0) </span><br><span class="line">&gt;&gt;&gt; <span class="builtin-name">print</span>(flag)</span><br><span class="line">g00dJ0B!</span><br></pre></td></tr></table></figure>

<h4 id="explore-技术"><a href="#explore-技术" class="headerlink" title="explore 技术"></a>explore 技术</h4><p>angr 提供了多种 <code>explore</code> 技术，即进行路径探索时所采用的策略，可以在 <code>angr.exploration_techniques</code> 条目下中找到。</p>
<p>每个策略都是 <code>ExplorationTechnique</code> 对象，根据策略不同，angr 对 <code>ExplorationTechnique</code> 中的 <code>setup、step</code> 等方法进行覆盖。</p>
<p>通过 <code>simgr.use_technique(tech)</code>设定不同的策略。</p>
<p>下面部分列出策略</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DFS</td>
<td>Depth first search. Keeps only one state active at once, putting the rest in the <code>deferred</code> stash until it deadends or errors.</td>
</tr>
<tr>
<td>LengthLimiter</td>
<td>Puts a cap on the maximum length of the path a state goes through.</td>
</tr>
<tr>
<td>Tracer</td>
<td>An exploration technique that causes execution to follow a dynamic trace recorded from some other source.</td>
</tr>
<tr>
<td>Oppologist</td>
<td>if this technique is enabled and angr encounters an unsupported instruction, it will concretize all the inputs to that instruction and emulate the single instruction using the unicorn engine, allowing execution to continue.</td>
</tr>
<tr>
<td>Threading</td>
<td>Adds thread-level parallelism to the stepping process.</td>
</tr>
<tr>
<td>Spiller</td>
<td>When there are too many states active, this technique can dump some of them to disk in order to keep memory consumption low.</td>
</tr>
</tbody></table>
<p>关于使用信息请查看 <a target="_blank" rel="noopener" href="http://angr.io/api-doc/angr.html#angr.exploration_techniques.ExplorationTechnique">API文档</a></p>
<h2 id="求解引擎"><a href="#求解引擎" class="headerlink" title="求解引擎"></a>求解引擎</h2><p>通过 <code>state.solver</code> 访问求解引擎，angr 的求解引擎是 <code>claripy</code> 用于求解约束。</p>
<h3 id="位向量-bitvector"><a href="#位向量-bitvector" class="headerlink" title="位向量(bitvector)"></a>位向量(bitvector)</h3><p>位向量是比特序列，既可以表示具体值，也可以是符号变量。</p>
<p>通过 <code>BVV(value,size)</code> 和 <code>BVS( name, size)</code> 接口创建位向量，也可以用 FPV 和 FPS 来创建浮点值和符号。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; one = <span class="keyword">state</span>.solver.BVV(<span class="number">1</span>, <span class="number">64</span>)</span><br><span class="line"> <span class="variable">&lt;BV64 0x1&gt;</span></span><br><span class="line">&gt;&gt;&gt; one_hundred = <span class="keyword">state</span>.solver.BVV(<span class="number">100</span>, <span class="number">64</span>)</span><br><span class="line"><span class="variable">&lt;BV64 0x64&gt;</span></span><br><span class="line">&gt;&gt;&gt; weird_nine = <span class="keyword">state</span>.solver.BVV(<span class="number">9</span>, <span class="number">27</span>)</span><br><span class="line"><span class="variable">&lt;BV27 0x9&gt;</span></span><br><span class="line">&gt;&gt;&gt; one + one_hundred</span><br><span class="line"><span class="variable">&lt;BV64 0x65&gt;</span></span><br><span class="line">&gt;&gt;&gt; one_hundred + <span class="number">0</span>x100</span><br><span class="line"><span class="variable">&lt;BV64 0x164&gt;</span></span><br><span class="line">&gt;&gt;&gt; one_hundred - one*<span class="number">200</span></span><br><span class="line"><span class="variable">&lt;BV64 0xffffffffffffff9c&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果两个位向量的长度不同无法进行运算的，需要将其扩展。 angr 提供 <code>zero_extend</code> 和 <code>sign_extend</code> 两种方式对向量进行拓展。</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">weird_nine.zero_extend(<span class="number">64</span> - <span class="number">27</span>)</span></span><br><span class="line">&lt;BV64 0x9&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">one + weird_nine.zero_extend(<span class="number">64</span> - <span class="number">27</span>)</span></span><br><span class="line">&lt;BV64 0xa&gt;</span><br></pre></td></tr></table></figure>

<p>创建符号变量：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = <span class="keyword">state</span>.solver.BVS(<span class="string">&quot;x&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="variable">&lt;BV64 x_9_64&gt;</span></span><br><span class="line">&gt;&gt;&gt; y = <span class="keyword">state</span>.solver.BVS(<span class="string">&quot;y&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="variable">&lt;BV64 y_10_64&gt;</span></span><br></pre></td></tr></table></figure>

<p>对其进行算术操作会得到 AST (抽象语法树)，而不是具体的值，AST 可以转化成约束，使用 SMT 求解器求解。</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x + one</span></span><br><span class="line">&lt;BV64 x_9_64 + 0x1&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">(x + one) / <span class="number">2</span></span></span><br><span class="line">&lt;BV64 (x_9_64 + 0x1) / 0x2&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x - y</span></span><br><span class="line">&lt;BV64 x_9_64 - y_10_64&gt;</span><br></pre></td></tr></table></figure>

<h4 id="符号约束"><a href="#符号约束" class="headerlink" title="符号约束"></a>符号约束</h4><p>将两个相似的 AST 进行比较会得到一个 AST, 这是符号化的布尔类型，使用 <code>solver.is_true</code>和 <code>solver.is_false</code> 获得真假值。</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x == <span class="number">1</span></span></span><br><span class="line">&lt;Bool x_9_64 == 0x1&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x == one</span></span><br><span class="line">&lt;Bool x_9_64 == 0x1&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x &gt; <span class="number">2</span></span></span><br><span class="line">&lt;Bool x_9_64 &gt; 0x2&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x + y == one_hundred + <span class="number">5</span></span></span><br><span class="line">&lt;Bool (x_9_64 + y_10_64) == 0x69&gt;</span><br></pre></td></tr></table></figure>

<h4 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h4><p>我们可以通过 <code>.add</code> 对 state 对象添加约束，并使用 <code>.eval</code> 接口求解，得到符号变量的可行解。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.solver.add(x &gt; y)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.solver.add(y &gt; <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.solver.add(<span class="number">10</span> &gt; x)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.solver.eval(x)</span><br></pre></td></tr></table></figure>

<p>因此，我们可以根据输出和限制得到输入值，举个例子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get a fresh state without constraints</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span> = proj.factory.entry_state()</span><br><span class="line">&gt;&gt;&gt; input = <span class="keyword">state</span>.solver.BVS(&#x27;input&#x27;, <span class="number">64</span>)</span><br><span class="line">&gt;&gt;&gt; operation = (((input + <span class="number">4</span>) * <span class="number">3</span>) &gt;&gt; <span class="number">1</span>) + input</span><br><span class="line">&gt;&gt;&gt; output = <span class="number">200</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.solver.add(operation == output)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">state</span>.solver.eval(input)</span><br><span class="line"><span class="number">0</span>x3333333333333381</span><br></pre></td></tr></table></figure>

<p>如果约束冲突，无法求解，则 state 为 <code>unsatisfiable</code> 状态，可以通过 <code>state.satisfiable()</code> 检查约束是否可解。</p>
<h4 id="更多求解方式"><a href="#更多求解方式" class="headerlink" title="更多求解方式"></a>更多求解方式</h4><p>除了朴素的 eval ，angr 提供了多种解析方式 。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>solver.eval(expression)</code></td>
<td>将会解出一个可行解</td>
</tr>
<tr>
<td><code>solver.eval_one(expression)</code></td>
<td>将会给出一个表达式的可行解，若有多个可行解，则抛出异常</td>
</tr>
<tr>
<td><code>solver.eval_upto(expression, n)</code></td>
<td>将会给出最多n个可行解，如果不足n个就给出所有的可行解。</td>
</tr>
<tr>
<td><code>solver.eval_exact(expression, n)</code></td>
<td>将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。</td>
</tr>
<tr>
<td><code>solver.min(expression)</code></td>
<td>给出最小可行解</td>
</tr>
<tr>
<td><code>solver.max(expression)</code></td>
<td>给出最大可行解</td>
</tr>
</tbody></table>
<p>同时可以设置 <code>extra_constraints</code> 和 <code>cast_to</code>参数对结果进行限制或转换。</p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>angr使用一系列引擎（SimEngine的子类）来模拟被执行代码对输入状态产生的影响。源码位于 angr/engines 目录下。</p>
<p>以下是默认的引擎列表</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>failure engine</code></td>
<td>kicks in when the previous step took us to some uncontinuable state</td>
</tr>
<tr>
<td><code>syscall engine</code></td>
<td>kicks in when the previous step ended in a syscall</td>
</tr>
<tr>
<td><code>hook engine</code></td>
<td>kicks in when the current address is hooked</td>
</tr>
<tr>
<td><code>unicorn engine</code></td>
<td>kicks in when the <code>UNICORN</code> state option is enabled and there is no symbolic data in the state</td>
</tr>
<tr>
<td><code>VEX engine</code></td>
<td>kicks in as the final fallback.</td>
</tr>
</tbody></table>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>angr 内置了许多程序分析方法。可以在 <code>angr.analyses</code> 下查看。</p>
<p>通过 <code>project.analyses.name</code> 进行调用，如 <code>project.analyses.CFGFast()</code> 。同时我们也可以编写自己的分析方法，具体可以查看 <a target="_blank" rel="noopener" href="https://docs.angr.io/extending-angr/analysis_writing">文档</a> 。</p>
<p>以下表格列出一些常用的方法。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th><code>描述</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>CFGFast</code></td>
<td>快速地获取程序控制流图(静态)</td>
</tr>
<tr>
<td><code>CFGEmulated</code></td>
<td>通过动态模拟获取程序控制流图</td>
</tr>
<tr>
<td><code>VFG</code></td>
<td>执行值集分析，生成值流图（Value Flow Graph）</td>
</tr>
<tr>
<td><code>DDG</code></td>
<td>数据依赖图</td>
</tr>
<tr>
<td><code>DFG</code></td>
<td>为每个在CFG中出现的基本块构建数据流图</td>
</tr>
<tr>
<td><code>BackwardSlice</code></td>
<td>后向切片</td>
</tr>
<tr>
<td><code>Identifier</code></td>
<td>库函数识别</td>
</tr>
</tbody></table>
<p>angr 文档仅对 <code>CFG、BackwardSlice、function Identifier</code> 这三种技术进行介绍，如果想使用其他技术，可以查看API / 源码或者向开发者提 issue 。</p>
<h3 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h3><p>CFGFast 使用静态分析获得 CFG, 速度较快，但是不太准确。 CFGEmulated 使用符号执行获得 CFG， 耗时长，相对准确。</p>
<p>如果不知道该选择哪一种，就先尝试 CFGFast 。</p>
<p>此外，angr 的 CFG 接口是 CFGFast 的简称，如果需要使用 CFGEmulated，请直接使用 CFGEmulated。</p>
<p>使用示例</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="keyword">import</span> angr</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">p = angr.Project(<span class="string">&#x27;/bin/true&#x27;</span>, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>: <span class="literal">False</span>&#125;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">cfg = p.analyses.CFGFast()</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <a target="_blank" rel="noopener" href="https://github.com/axt/angr-utils">angr-utils</a> 对 CFG, CG 图进行可视化。</p>
<h3 id="backward-slicing"><a href="#backward-slicing" class="headerlink" title="backward slicing"></a>backward slicing</h3><p>用于后向切片，为了构建一个 BackwardSlice，我们需要以下信息作为输入：</p>
<ul>
<li><p>CFG（必须）： A control flow graph (CFG) of the program. This CFG must be an accurate CFG (CFGEmulated).</p>
</li>
<li><p>Target （必须）： Target, which is the final destination that your backward slice terminates at.</p>
</li>
<li><p>CDG （可选）：A control dependence graph (CDG) derived from the CFG.</p>
<p>angr has a built-in analysis <code>CDG</code> for that purpose.</p>
</li>
<li><p>DDG （可选） A data dependence graph (DDG) built on top of the CFG.</p>
<p>angr has a built-in analysis <code>DDG</code> for that purpose.</p>
</li>
</ul>
<p>以下是文档的使用示例</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import angr</span><br><span class="line"><span class="comment"># Load the project</span></span><br><span class="line">&gt;&gt;&gt; b = angr.Project(<span class="string">&quot;examples/fauxware/fauxware&quot;</span>, load_options=&#123;<span class="string">&quot;auto_load_libs&quot;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a CFG first. In order to generate data dependence graph afterwards, you’ll have to:</span></span><br><span class="line"><span class="comment"># - keep all input states by specifying keep_state=True.</span></span><br><span class="line"><span class="comment"># - store memory, register and temporary values accesses by adding the angr.options.refs option set.</span></span><br><span class="line"><span class="comment"># Feel free to provide more parameters (for example, context_sensitivity_level) for CFG </span></span><br><span class="line"><span class="comment"># recovery based on your needs.</span></span><br><span class="line">&gt;&gt;&gt; cfg = b.analyses.CFGEmulated(<span class="attribute">keep_state</span>=<span class="literal">True</span>, </span><br><span class="line"><span class="built_in">..</span>.                              <span class="attribute">state_add_options</span>=angr.sim_options.refs, </span><br><span class="line"><span class="built_in">..</span>.                              <span class="attribute">context_sensitivity_level</span>=2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成控制流依赖图</span></span><br><span class="line">&gt;&gt;&gt; cdg = b.analyses.CDG(cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据流依赖图</span></span><br><span class="line">&gt;&gt;&gt; ddg = b.analyses.DDG(cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># See where we wanna go... let’s go to the exit() call, which is modeled as a </span></span><br><span class="line"><span class="comment"># SimProcedure.</span></span><br><span class="line">&gt;&gt;&gt; target_func = cfg.kb.functions.function(<span class="attribute">name</span>=<span class="string">&quot;exit&quot;</span>)</span><br><span class="line"><span class="comment"># We need the CFGNode instance</span></span><br><span class="line">&gt;&gt;&gt; target_node = cfg.get_any_node(target_func.addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let’s get a BackwardSlice out of them!</span></span><br><span class="line"><span class="comment"># `targets` is a list of objects, where each one is either a CodeLocation </span></span><br><span class="line"><span class="comment"># object, or a tuple of CFGNode instance and a statement ID. Setting statement </span></span><br><span class="line"><span class="comment"># ID to -1 means the very beginning of that CFGNode. A SimProcedure does not </span></span><br><span class="line"><span class="comment"># have any statement, so you should always specify -1 for it.</span></span><br><span class="line">&gt;&gt;&gt; bs = b.analyses.BackwardSlice(cfg, <span class="attribute">cdg</span>=cdg, <span class="attribute">ddg</span>=ddg, targets=[ (target_node, -1) ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Here is our awesome program slice!</span></span><br><span class="line">&gt;&gt;&gt; <span class="builtin-name">print</span>(bs)</span><br></pre></td></tr></table></figure>

<h3 id="function-identifier"><a href="#function-identifier" class="headerlink" title="function identifier"></a>function identifier</h3><p>用于识别库函数，目前仅针对 CGC 文件。</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="keyword">import</span> angr</span></span><br><span class="line"></span><br><span class="line"># get all the matches</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">p = angr.Project(<span class="string">&quot;../binaries/tests/i386/identifiable&quot;</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">idfer = p.analyses.Identifier()</span></span><br><span class="line"># note that .run() yields results so make sure to iterate through them or call list() etc</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="keyword">for</span> addr, symbol <span class="keyword">in</span> idfer.run():</span></span><br><span class="line"><span class="meta">...</span> <span class="python">    <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), symbol)</span></span><br><span class="line"></span><br><span class="line">0x8048e60 memcmp</span><br><span class="line">0x8048ef0 memcpy</span><br><span class="line">0x8048f60 memmove</span><br><span class="line">0x8049030 memset</span><br><span class="line">0x8049320 fdprintf</span><br><span class="line">0x8049a70 sprintf</span><br><span class="line">0x8049f40 strcasecmp</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>因为 angr 在不断更新，很多接口也在变化，网上有些教程有点过时，看不同版本的教程可能会有点乱，这里主要说一下在其他教程中经常出现但是已经发生变更的接口。</p>
<ul>
<li><code>SimuVEX</code> 已被移除</li>
<li><code>Surveyors</code> 已被移除</li>
<li>使用 Simulation Manager 代替 Path Group</li>
<li>求解引擎的接口是 state.solver 而不是 state.se</li>
<li><code>CFGAccurate</code> 更名为 <code>CFGEmulated.</code></li>
</ul>
<p>更详细的可以看 <a target="_blank" rel="noopener" href="https://docs.angr.io/appendix/changelog">changelog</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">violet-233</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2021/11/18/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">violet-233の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/re/">re</a></div><div class="post_share"><div class="social-share" data-image="https://eternitywith.gitee.io/image/32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/18/vm-protect%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vm protect学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/17/N1BOOK/"><img class="next-cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">N1BOOK-案例</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/17/2021%E8%BE%BD%E5%AE%81%E7%9C%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9Bwp%E5%A4%8D%E7%8E%B0/" title="2021辽宁省网络安全技术大赛wp复现"><img class="cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/40.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-17</div><div class="title">2021辽宁省网络安全技术大赛wp复现</div></div></a></div><div><a href="/2022/01/22/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B/" title="ACTF新生赛"><img class="cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/40.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-22</div><div class="title">ACTF新生赛</div></div></a></div><div><a href="/2021/12/05/DUNICTF-WP/" title="DUNICTF-WP"><img class="cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">DUNICTF-WP</div></div></a></div><div><a href="/2021/11/22/V-N2020%E5%85%AC%E5%BC%80%E8%B5%9Bre%E5%A4%8D%E7%8E%B0/" title="V&N2020公开赛re复现"><img class="cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">V&N2020公开赛re复现</div></div></a></div><div><a href="/2022/01/06/NewCrackme160/" title="NewCrackme160"><img class="cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/40.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-06</div><div class="title">NewCrackme160</div></div></a></div><div><a href="/2021/11/20/angr-%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0/" title="angr进阶练习"><img class="cover" src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/40.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">angr进阶练习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../images/loading.png" data-original="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">violet-233</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/violet-233" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">符号执行介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#angr%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">angr上手教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">顶层接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loader"><span class="toc-number">2.3.</span> <span class="toc-text">loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#factory"><span class="toc-number">2.4.</span> <span class="toc-text">factory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#blocks"><span class="toc-number">2.4.1.</span> <span class="toc-text">blocks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#states"><span class="toc-number">2.4.2.</span> <span class="toc-text">states</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simulation-Managers"><span class="toc-number">2.4.3.</span> <span class="toc-text">Simulation Managers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyses"><span class="toc-number">2.5.</span> <span class="toc-text">Analyses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loader-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">loader 加载模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">已加载的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%92%8C%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.2.</span> <span class="toc-text">符号和重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AC%A6%E5%8F%B7"><span class="toc-number">3.2.1.</span> <span class="toc-text">查找符号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%80%89%E9%A1%B9"><span class="toc-number">3.3.</span> <span class="toc-text">加载选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%80%89%E9%A1%B9"><span class="toc-number">3.3.1.</span> <span class="toc-text">基本选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pre-binary-%E9%80%89%E9%A1%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">pre-binary 选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#backend"><span class="toc-number">3.4.</span> <span class="toc-text">backend</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%87%BD%E6%95%B0%E6%91%98%E8%A6%81%E9%9B%86-symbolic-funcion-summaries"><span class="toc-number">4.</span> <span class="toc-text">符号函数摘要集(symbolic funcion summaries)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hooking"><span class="toc-number">4.0.1.</span> <span class="toc-text">Hooking</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#states-1"><span class="toc-number">5.</span> <span class="toc-text">states</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%89%A7%E8%A1%8C"><span class="toc-number">5.0.1.</span> <span class="toc-text">基础执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E9%A2%84%E8%AE%BE"><span class="toc-number">5.0.2.</span> <span class="toc-text">状态预设</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.0.3.</span> <span class="toc-text">访问寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98"><span class="toc-number">5.0.4.</span> <span class="toc-text">访问内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E9%80%89%E9%A1%B9"><span class="toc-number">5.0.5.</span> <span class="toc-text">状态选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%8F%92%E4%BB%B6%EF%BC%88state-plugin"><span class="toc-number">5.0.6.</span> <span class="toc-text">状态插件（state plugin)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#history-%E6%8F%92%E4%BB%B6"><span class="toc-number">5.0.6.1.</span> <span class="toc-text">history 插件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%A0%88%EF%BC%88callstack%EF%BC%89%E6%8F%92%E4%BB%B6"><span class="toc-number">5.0.6.2.</span> <span class="toc-text">调用栈（callstack）插件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88Simulation-Managers"><span class="toc-number">6.</span> <span class="toc-text">模拟管理器（Simulation Managers)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">6.1.</span> <span class="toc-text">执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stash-%E7%AE%A1%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">stash 管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explore"><span class="toc-number">6.3.</span> <span class="toc-text">explore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#explore-%E6%8A%80%E6%9C%AF"><span class="toc-number">6.3.1.</span> <span class="toc-text">explore 技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3%E5%BC%95%E6%93%8E"><span class="toc-number">7.</span> <span class="toc-text">求解引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%90%91%E9%87%8F-bitvector"><span class="toc-number">7.1.</span> <span class="toc-text">位向量(bitvector)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">符号约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3"><span class="toc-number">7.1.2.</span> <span class="toc-text">约束求解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%B1%82%E8%A7%A3%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.3.</span> <span class="toc-text">更多求解方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">8.</span> <span class="toc-text">执行引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CFG"><span class="toc-number">9.1.</span> <span class="toc-text">CFG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#backward-slicing"><span class="toc-number">9.2.</span> <span class="toc-text">backward slicing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function-identifier"><span class="toc-number">9.3.</span> <span class="toc-text">function identifier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">10.</span> <span class="toc-text">更新说明</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/finger%E5%AE%89%E8%A3%85/" title="finger安装"><img src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/43.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="finger安装"/></a><div class="content"><a class="title" href="/2022/11/14/finger%E5%AE%89%E8%A3%85/" title="finger安装">finger安装</a><time datetime="2022-11-14T12:11:51.000Z" title="发表于 2022-11-14 20:11:51">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/ollvm/" title="ollvm"><img src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/40.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ollvm"/></a><div class="content"><a class="title" href="/2022/11/14/ollvm/" title="ollvm">ollvm</a><time datetime="2022-11-14T10:58:30.000Z" title="发表于 2022-11-14 18:58:30">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/31/ctfwiki/" title="ctfwiki"><img src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ctfwiki"/></a><div class="content"><a class="title" href="/2022/10/31/ctfwiki/" title="ctfwiki">ctfwiki</a><time datetime="2022-10-31T07:52:57.000Z" title="发表于 2022-10-31 15:52:57">2022-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/%E6%9D%82%E8%B0%88%E2%80%94%E2%80%94%E9%87%8D%E5%AE%9A%E5%90%91/" title="杂谈——重定向"><img src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="杂谈——重定向"/></a><div class="content"><a class="title" href="/2022/10/24/%E6%9D%82%E8%B0%88%E2%80%94%E2%80%94%E9%87%8D%E5%AE%9A%E5%90%91/" title="杂谈——重定向">杂谈——重定向</a><time datetime="2022-10-24T11:11:25.000Z" title="发表于 2022-10-24 19:11:25">2022-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/21/%E5%88%86%E4%BA%AB%E4%BC%9A/" title="分享会"><img src="../images/loading.png" data-original="https://eternitywith.gitee.io/image/16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分享会"/></a><div class="content"><a class="title" href="/2022/10/21/%E5%88%86%E4%BA%AB%E4%BC%9A/" title="分享会">分享会</a><time datetime="2022-10-21T08:23:18.000Z" title="发表于 2022-10-21 16:23:18">2022-10-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By violet-233</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>